service HelloWorld
    ExampleMethod()

service GeneralLedger
    SaveGlEvent(GlEvent, SourceCreationDate) oneway
    SaveGlAccount(GlAccount) oneway
    RevertGlEvent(Date, GlEventType, SourceId) oneway
    GetGlEvent(Date, GlEventType, SourceId): GlEvent[*]
    GetRevertedGlEvents(Date, GlEventType, SourceId):GlEvents
    GelAllAccounts():GlAccounts


procedure SaveGlAccount(GlAccount)
    if BankTransaction.currentMatchInfo.details.Where(d => d is ServiceAccountBankTransactionMatchDetail).Any(d => (d as ServiceAccountBankTransactionMatchDetail).invoiceId == MtpTransactionMatchDetail.invoiceId)

procedure GetCustomerAccountListByIdList(AccountIds, out AccountList)
    AccountList = new
    foreach AccountId in AccountIds
        call GetUserAccountById(AccountId, out Account)
        AccountList ++= Account

procedure ProccessMailAssignmentRequest(GlAccount, MailAssignmentRequest)
    MailAssignmentResultDetailsCollection = MailAssignmentRequest.mailAssignmentRequestDetailsCollection
        .Where(x => AccountIdsByEmail.ContainsKey(x.senderEmail) && !(AccountIdsByEmail[x.senderEmail].Count > 1))
        .Select
            (
                x =>
                    new MailAssignmentResultDetails (
                            accountId = AccountIdsByEmail[x.senderEmail].First(),
                            mailId = x.mailId
                    )
            )

    MailIds = MailAssignmentRequest.mailAssignmentRequestDetailsCollection
        .Where(x => !MailAssignmentResultDetailsCollection.Any(y => y.mailId == x.mailId))
        .Select(mailId)

    MailAssignmentResult = new MailAssignmentResult
        (
            mailAssignmentResultDetailsCollection = MailAssignmentResultDetailsCollection,
            unassignedMailIds = MailIds
        )

    MailStorageAsync.ProcessMailAssignmentResult(MailAssignmentResult)

formula ToCreateServiceAccountRequest(Order, Proposition):CreateServiceAccountRequest = new CreateServiceAccountRequest(
    shippingAddress = Order.shippingAddress.ToCreateAddressRequest(),
    startOn = Order.startOn,
    endOn = Order.endOn,
    propositionId = Order.propositionId,
    serviceCategoryId = Order.serviceCategoryId,
    paymentMethod = Order.paymentMethod,
    initialInvoicePaymentMethod = Order.initialInvoicePaymentMethod,
    email = Order.customer.contactInfo.email,
    subscribedCashback = if (Order.isEnergieCustomer, Proposition.cashback, empty))


procedure CreateMyNleAccount(CreateCustomerAccountRequest, out AccountId)
    AccountId = IdGenerator.GetNextAvailableId(TypeOfId.AccountId)
    call CreateCustomerAccountInternal(AccountId, CreateCustomerAccountRequest)

procedure CreateCustomerAccountInternal(AccountId, CreateCustomerAccountRequest)
    Email = CreateCustomerAccountRequest.contactInfo.email
    Name = CreateCustomerAccountRequest.firstName + " " + CreateCustomerAccountRequest.lastName

    CustomerAccount = CreateCustomerAccountRequest.FromDto(AccountId)
    CustomerAccounts[AccountId] = CustomerAccount
    Accounts[AccountId] = CustomerAccount
    AccountIdsByEmail[Email] ++= AccountId


procedure GetSubscribedAvailableBundlesPerProduct(OrderId, CreateSubscriptionRequestCollection, out SubscribedBundlesPerProduct)
    SubscribedBundlesPerProduct = new
    AvailableProposition = Fulfillment.GetAvailablePropositonByOrderId(OrderId)

    if AvailableProposition is not empty
        AvailableProducts = AvailableProposition.products

        foreach CreateSubscriptionRequest in CreateSubscriptionRequestCollection
            SubscribeBundleWithDiscountRequests = CreateSubscriptionRequest.subscribeBundleWithDiscountRequests
            if AvailableProducts is empty
                error[EmptyArgument] "No available products connected with available proposition"
            AvailableProduct = AvailableProducts.First(x => x.id == CreateSubscriptionRequest.productId)
            BundleIds = SubscribeBundleWithDiscountRequests.Select(x => x.bundleId)
            let Bundles = AvailableProduct.bundles.Where(x => BundleIds.Contains(x.id))
            ProductId = CreateSubscriptionRequest.productId
            Product = ProductCatalog.GetProductById(ProductId)
            PricePlanId = Product.pricePlan.id

            foreach AvailableBundle in Bundles
                DiscountId = SubscribeBundleWithDiscountRequests.First(x => x.bundleId == AvailableBundle.id).discountId // unneeded ?
                BundleId = AvailableBundle.id
                if !IsEmpty(DiscountId)
                    Discount = ProductCatalog.GetDiscountById(PricePlanId, BundleId)

                    Amount = Discount.GetDiscountedAmount(AvailableBundle.price)

                    AvailableBundle.additionalInfos ++= new AdditionalInfo(name = "discountedPrice", value = Amount + "")
                    AvailableBundle.discountId = Discount.id
            if AvailableProduct.typeOfServiceId == InternetTypeOfServiceId
                SubscribedBundlesPerProduct.internetBundles = Bundles
            else if AvailableProduct.typeOfServiceId == TvTypeOfServiceId
                SubscribedBundlesPerProduct.tvBundles = Bundles
            else if AvailableProduct.typeOfServiceId == VoipTypeOfServiceId
                SubscribedBundlesPerProduct.voipBundles = Bundles
            else
                MethodInfo("Test")

procedure UpdateCustomerAccount(UpdateCustomerAccountRequest)
    if IsEmpty(UpdateCustomerAccountRequest.accountId)
        error[InvalidAccountId] "Customer account id cannot be empty"
    call GetCustomerAccountById(AccountId = UpdateCustomerAccountRequest.accountId, out CustomerAccount)
    if UpdateCustomerAccountRequest.createdBy is empty
        error[InvalidCreatedBy] "Created by cannot be empty"


procedure CrmPortalGetFilteredAndPagedServiceInformation(Input, FullyMatchedPaginationInfo, PartiallyMatchedPaginationInfo, out CrmPortalGetFilteredAndPagedServiceDeliveryInformationResponse)
    if IsEmpty(Input) || Input.Length < MinSearchQueryLength
        CrmPortalGetFilteredAndPagedServiceDeliveryInformationResponse = new
        return
    CrmPortalGetFilteredAndPagedServiceDeliveryInformationResponse = CrmBackend.GetFilteredAndPagedServiceInformation(Input, FullyMatchedPaginationInfo, PartiallyMatchedPaginationInfo).ToDto()

generic procedure GetPropositionsFilteredBy(FilterQuery, PropositionCollection, out PropositionFilteredCollection)
    error [GenericObjectPassed] "You've passed generic FilterQuery object. Try specific one (ProductCatalogNameFilter, ProductCatalogServiceFilter, etc.")

specific procedure GetPropositionsFilteredBy(ProductCatalogIdFilter, PropositionCollection, out PropositionFilteredCollection)
    PropositionFilteredCollection = PropositionCollection.Where(p => p.id.ToLower() == ProductCatalogIdFilter.id.Trim().ToLower())

specific procedure GetPropositionsFilteredBy(ProductCatalogNameFilter, PropositionCollection, out PropositionFilteredCollection)
    PropositionFilteredCollection = PropositionCollection.Where(p => p.name.ToLower().Contains(ProductCatalogNameFilter.name.Trim().ToLower()))


